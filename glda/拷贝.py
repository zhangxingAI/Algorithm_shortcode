'''
小王正在玩一款新的即时战略游戏。他有一个军团，排成一排n个士兵，每个士兵都由系统随机分配了一个外观，用整数表示，这n个士兵的外观分别为a1，a2•••an。
小王想要拥有一支整齐外观的军团，于是打开了他的游戏编辑器。
游戏编辑器允许小王选择一个长度为不大于n的任意偶数（例如2m）的区间［L，L+2m-1|（1≤L≤n=2m +1，注意小王选择的区间不能超过士兵范围）
使得对于其中左半区间内十兵的外观设置为右半区间士兵的外观。
形式化地，游戏编辑器会做这样的操作：对于给定2m和L，设置ai= a{i + m}（L ≤i ≤ L+ m - 1）。
小干想知道他至少做多少次这样的拷贝操作，能让他军团中所有士兵拥有相同的外观。

输入描述

第一行1个整数为n，表示士兵数量。
第二行n个整数a1a2•••an。分别表示这n个士兵的外观
1≤n≤ 50000， 1≤ai ≤n

输出描述
输出一行一个数表示最少拷贝操作数量，使得所有士兵拥有相同外观。

输入
4
1 2 2 2
输出
1

输入
4
1 2 3 4
输出
2

样例解释
样例1中，选择区间［1，2］，将第二个士兵的外观拷贝给第一个土兵即可让所有士兵拥有相同的外观。
样例2中，可以将区间［3，4]进行拷贝，变为1244，之后对区间［1，4]拷贝即可让所有士兵拥有相同的外观，共两次操作。
'''
n = int(input())
s = list(map(int, input().split(' ')))
operate = 0
i = -1
while i >= -1*int(n/2):
    if s[i-1] != s[i]:
        operate += 1
        i = i*2+1
        for j in range(-1,i-1,-1):
            s[i] = s[-1]
    i -= 1
print(i,operate,-1*int(n/2))

for i in range(0,int(n/2)):
    if s[i] != s[-1]:
        operate +=1
        break

print(operate)
'''
5
5 2 3 4 5
'''
